filter {
  if [@metadata][stage] == 'suricata_json' {

    mutate {
      add_field => {
        "[related][domain]" => []
        "[related][ip]" => []
        "[related][id]" => []
        "[related][hash]" => []
        "[related][vlan]" => []
        "[event][module]" => "suricata"
        "[event][created]" => "%{[@timestamp]}"
        "[event][version]" => "1.0.0"
        "[event][category]" => "network"
      }

      # Make this compatible with event.id as a string
      convert => { "[flow_id]" => "string" }

      rename => {
        "event_type" => "[event][dataset]"
        "flow_id" => "[event][id]"
        "proto" => "[network][transport]"
      }

      lowercase => [ "[network][transport]" ]

      merge => {"[event][id]" => "[related][id]" }
    }

    # Set the timestamp from the event
    date {
      match => [ "timestamp", "ISO8601" ]
      tag_on_failure => [ "_dateparsefailure", "_parsefailure", "_suricata_dateparsefailure" ]
      remove_field => [ "timestamp" ]
    }

    # Suricata uses top-level src/dest to track flow
    if [src_ip] {
      mutate {
        rename => {
          "[src_ip]" => "[source][ip]"
          "[src_port]" => "[source][port]"
        }
        merge => { "[related][ip]" => "[source][ip]" }
      }
    }
    if [dest_ip] {
      mutate {
        rename => {
          "[dest_ip]" => "[destination][ip]"
          "[dest_port]" => "[destination][port]"
        }
        merge => { "[related][ip]" => "[destination][ip]" }
      }
    }

    if [vlan] {
      mutate {
        rename => { "[vlan]" => "[vlan][id]" }
        merge => { "[related][vlan]" => "[vlan][id]" }
      }
    }

    if [app_proto] {
      if [app_proto] == "failed" {
        # delete failed detections to be consistent with bro
        mutate { remove_field => ["app_proto"] }
      }
      else {
        mutate { rename => {"[app_proto]" => "[network][protocol]"}}
      }
    }


    #if [alert] {

    #}

  }
}
